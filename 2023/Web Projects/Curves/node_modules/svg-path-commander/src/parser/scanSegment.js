import finalizeSegment from 'svg-path-commander/src/parser/finalizeSegment';
import paramCounts from 'svg-path-commander/src/parser/paramsCount';
import scanFlag from 'svg-path-commander/src/parser/scanFlag';
import scanParam from 'svg-path-commander/src/parser/scanParam';
import skipSpaces from 'svg-path-commander/src/parser/skipSpaces';
import isPathCommand from 'svg-path-commander/src/parser/isPathCommand';
import isDigitStart from 'svg-path-commander/src/parser/isDigitStart';
import isArcCommand from 'svg-path-commander/src/parser/isArcCommand';
import invalidPathValue from 'svg-path-commander/src/parser/invalidPathValue';
import error from 'svg-path-commander/src/parser/error';

/**
 * Scans every character in the path string to determine
 * where a segment starts and where it ends.
 *
 * @param {SVGPath.PathParser} path the `PathParser` instance
 */
export default function scanSegment(path) {
  const { max, pathValue, index } = path;
  const cmdCode = pathValue.charCodeAt(index);
  const reqParams = paramCounts[pathValue[index].toLowerCase()];

  path.segmentStart = index;

  if (!isPathCommand(cmdCode)) {
    path.err = `${error}: ${invalidPathValue} "${pathValue[index]}" is not a path command`;
    return;
  }

  path.index += 1;
  skipSpaces(path);

  path.data = [];

  if (!reqParams) {
    // Z
    finalizeSegment(path);
    return;
  }

  for (;;) {
    for (let i = reqParams; i > 0; i -= 1) {
      if (isArcCommand(cmdCode) && (i === 3 || i === 4)) scanFlag(path);
      else scanParam(path);

      if (path.err.length) {
        return;
      }
      path.data.push(path.param);

      skipSpaces(path);

      // after ',' param is mandatory
      if (path.index < max && pathValue.charCodeAt(path.index) === 0x2C/* , */) {
        path.index += 1;
        skipSpaces(path);
      }
    }

    if (path.index >= path.max) {
      break;
    }

    // Stop on next segment
    if (!isDigitStart(pathValue.charCodeAt(path.index))) {
      break;
    }
  }

  finalizeSegment(path);
}
